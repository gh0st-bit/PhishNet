import { BaseThreatFeedProvider, ThreatData } from './threat-feed-base';

export class MalwareDomainsFeedProvider extends BaseThreatFeedProvider {
  name = 'malwaredomainlist';
  
  private readonly FEED_URLS = {
    domains: 'http://www.malwaredomainlist.com/mdlcsv.php',
    ips: 'http://www.malwaredomainlist.com/hostslist/ip.txt'
  };

  async fetchThreats(): Promise<ThreatData[]> {
    try {
      console.log(`[${this.name}] Fetching malware domains...`);
      
      const response = await this.withTimeout(
        this.fetchWithRetry(this.FEED_URLS.domains),
        15000
      );
      
      const csvText = await response.text();
      const threats = this.parseCsvData(csvText);

      console.log(`[${this.name}] Successfully fetched ${threats.length} malware domains`);
      return threats;
      
    } catch (error) {
      console.error(`[${this.name}] Error fetching threats:`, error);
      return [];
    }
  }

  private parseCsvData(csvText: string): ThreatData[] {
    try {
      const lines = csvText.split('\n');
      
      // Skip header and empty lines
      const dataLines = lines
        .slice(1)
        .filter(line => line.trim())
        .slice(0, 150); // Limit to 150 entries

      return dataLines
        .map(line => this.parseCsvLine(line))
        .filter(Boolean) as ThreatData[];
        
    } catch (error) {
      console.warn(`[${this.name}] Error parsing CSV:`, error);
      return [];
    }
  }

  private parseCsvLine(line: string): ThreatData | null {
    try {
      // Parse CSV line (be careful with quotes and commas)
      const fields = this.parseCSVLine(line);
      
      if (fields.length < 4) return null;

      const [dateStr, url, ip, , description] = fields;
      
      if (!url || url === '"-"' || !url.includes('.')) return null;

      const cleanUrl = url.replace(/"/g, '');
      const domain = this.extractDomain(cleanUrl) || cleanUrl;
      
      if (!domain || domain.length < 3) return null;

      return {
        url: cleanUrl.startsWith('http') ? cleanUrl : `http://${cleanUrl}`,
        domain,
        indicator: domain,
        indicatorType: 'domain',
        threatType: 'malware',
        confidence: 80,
        firstSeen: this.parseDate(dateStr?.replace(/"/g, '')),
        description: description?.replace(/"/g, '') || `Malware hosting domain: ${domain}`,
        tags: ['malware', 'hosting'],
        source: this.name,
        rawData: { csv_line: line, ip: ip?.replace(/"/g, '') }
      };
    } catch (error) {
      console.warn(`[${this.name}] Error parsing CSV line:`, error);
      return null;
    }
  }

  private parseCSVLine(line: string): string[] {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    
    result.push(current);
    return result;
  }

  private parseDate(dateStr?: string): Date {
    if (!dateStr) return new Date();
    
    try {
      const date = new Date(dateStr);
      return isNaN(date.getTime()) ? new Date() : date;
    } catch {
      return new Date();
    }
  }
}